/*******************************************************************************
//  6VCPgawoc.cpp                    Author: Ian Nobile
//  Section: 50                     Due Date: 15 November 2021
//
//  This program crafts an approximate solution to a minimum vertex cover
//  problem provided a .GPH dataset. It utilises a Wisdom of Crowds algorithm
//  that aggregates the best solutions generated by a genetic algorithm (HVX, by
//  Drs. Kotecha and Gambhava) with random mutations (single flipped bit) and
//  uses them to build consensus on a good-enough vertex count and cover. It
//  then reports a set of relevant statistics at the end of program execution
//
*******************************************************************************/

constexpr int V = ??? + 1;  // change to the number of vertices in your .gph file
constexpr int E = ???;      // change to the number of edges in your .gph file

#include <iostream> // print to console
#include <chrono>   // time the speed of the program
#include <fstream>  // read files
#include <string>   // header buffer for seeking inside a file
#include <array>    // easy arraying
#include <bitset>   // std::bitset
#include <vector>   // easy arraying
#include <algorithm>// easy array shuffling
#include <random>   // easy array shuffling

using namespace std;
using namespace std::chrono;

// class declarations:
class Edge {
public:
    int u;
    int v;
    bool covered;
};

// function prototypes:
vector<Edge> buildGraph(char*);
bool covered(vector<Edge>);
bitset<V> buildCover(vector<Edge>, array<int, V>);
bitset<V> mutate(bitset<V> o, vector<Edge> graph, int mutatee);
void lot(bitset<V>&, vector<Edge>);
bitset<V> hvx(bitset<V>, bitset<V>, array<int, V>, vector<Edge>, int);

//------------------------------------------------------------------------------
//  Main Function
//------------------------------------------------------------------------------
int main(int argc, char* argv[]) {
    // check if path was passed as arg:
    if (argc == 1) {
        cout << "Please pass the path to the .gph file as a command line argument" << endl;
        return 1;
    }

    auto start = high_resolution_clock::now();  // start timer

    // begin with a friendly greeting
    cout << "Hello and welcome to the (Genetic Algorithm - Wisdom of Crowds) Vertex Cover Problem Solver" << endl << endl;

    // fill graph
    vector<Edge> graph = buildGraph(argv[1]);
    if (graph.size() == 0) {
        // minimum vertex cover is zero
        cout << "The minimum vertex cover is zero for this dataset" << endl;
        return 0;
    }
    else if (graph.size() == 1) {
        // minimum vertex cover is one
        cout << "The minimum vertex cover is one for this dataset, either vertex " << graph[0].u << " or " << graph[0].v << " must be covered" << endl;
        return 0;
    }

    /*
    // graphing (in pycharm):
    import networkx as nx
    import matplotlib.pyplot as plt

    covers = [] // a list of the covered nodes
    color_map = []
    G = nx.Graph()

    G.add_edges_from([])    // a list of the edges

    for node in G :
        if node in covers :
            color_map.append('red')
        else :
            color_map.append('blue')

    #nx.draw(G, with_labels = True, font_weight = 'bold', node_color = color_map)
    plt.show()
    */

    array<int, V> score;
    fill(score.begin(), score.end(), 0);
    for (int i = 0; i < E; i++) {
        score[graph[i].u]++;
        score[graph[i].v]++;
    }

    // prep rng and mating, mutation and mutatee distributions
    mt19937 mt(time(nullptr)); // rng; Google: rand-Considered-Harmful
    uniform_int_distribution<int> distMate(0, 49);
    uniform_real_distribution<double> distMut(0, 1);
    uniform_int_distribution<int> distMutee(1, 100);

    //WoC Cycle:
    array<bitset<V>, 100> crowd;
    for (int crowdCounter = 0; crowdCounter < crowd.size(); crowdCounter++) {   //for (size_t i = 0, ilen = things.size(); i < ilen; ++i) { /**/ }  ???
        // create an initial population of N totally randomised covers
        array<bitset<V>, 100> pop;
        for (int i = 0;i < pop.size();i++) {
            shuffle(graph.begin(), graph.end(), mt);
            bitset<V> cover = buildCover(graph, score);
            pop[i] = cover;
        }

        //Main Loop: (Genetic Algorithm)
        for (int upperBound = 1;upperBound < 101;upperBound++) {
            // sort by number of vertices
            sort(pop.begin(), pop.end(), [](bitset<V> a, bitset<V> b) { return a.count() < b.count(); });

            // randomly mate top N/2 fittest and store offspring in newPop
            array<bitset<V>, 100> newPop;
            int p1Index = 0, p2Index = 0;
            int mutatee = 0;
            for (int i = 0; i < newPop.size(); i++) {
                p1Index = distMate(mt);
                do {
                    p2Index = distMate(mt);
                } while (p1Index == p2Index);
                mutatee = (distMut(mt) < 0.1) ? distMutee(mt) : 0;
                newPop[i] = hvx(pop[p1Index], pop[p2Index], score, graph, mutatee);
                lot(newPop[i], graph);  // local optimisation technique
            }
            pop = newPop;
        } // end Main Loop

        sort(pop.begin(), pop.end(), [](bitset<V> a, bitset<V> b) { return a.count() < b.count(); });
        crowd[crowdCounter] = pop[0];   // capture most fit solution

    } // end WoC Cycle


    sort(crowd.begin(), crowd.end(), [](bitset<V> a, bitset<V> b) { return a.count() < b.count(); });
    cout << "This diverse crowd has " << crowd.size() << " members. The min is " << crowd[0].count() << " and the max is " << crowd[crowd.size() - 1].count() << endl;

    // calc average
    float avg = 0;
    for (int i = 0;i < crowd.size();i++) {
        avg += crowd[i].count();
    }
    avg /= crowd.size();
    cout << "The crowd currently believe that the optimal minimum vertex cover will require " << avg << " covered vertices" << endl << endl;

    // find the most common count:
    int current = crowd[0].count(), previous = 0, count = 1, max = 1, maxB = 0;
    for (int i = 1; i < crowd.size(); i++) {
        previous = current;
        current = crowd[i].count();
        if (current == previous) {
            count++;
        }
        else {
            if (count > max) {
                maxB = i - 1;
                max = count;
            }
            count = 1;
        }
    }
    if (count > max) {
        maxB = crowd.size() - 1;
        max = count;
    }
    int maxA = maxB - max + 1;  // create bounds of mcvc


    // crowdsource most common cover:
    string mcvc = "", nocon = "";
    bool changed = false;

    for (int j = 1; j < V; j++) {
        changed = false;
        current = crowd[maxA][j];
        for (int i = maxA; i < maxB; i++) {
            previous = current;
            current = crowd[i][j];
            if (current == previous) {
                continue;
            }
            else {
                changed = true;
                break;
            }
        }
        if (changed) {
            mcvc.append("_");
            nocon.append(to_string(j));
            nocon.append(" ");
        }
        else {
            mcvc.append(to_string(current));
        }
    }

    // report res
    cout << "The crowdsourced minimum vertex cover looks like this: " << endl << endl << "\t" << mcvc << endl << endl;
    cout << "where 0 means uncovered, 1 means covered, and the gaps (if there are any) are the positions around which" << endl;
    cout << "no consensus could be built. Those gaps include vertices " << nocon << endl << endl;
    cout << "One possible solution is" << endl << endl << "\t";
    for (int i = 1; i < V; i++) {
        cout << crowd[maxA][i];
    }

    cout << endl << endl << "The number of covered vertices is " << crowd[maxA].count() << ", " << (int)avg - (int)crowd[maxA].count() << " less than that originally projected" << endl;
    if (crowd[maxA].count() == crowd[0].count()) {
        cout << "but equal to the current optimal path, " << crowd[0].count() << "!" << endl << endl;
    }
    else if (crowd[maxA].count() > crowd[0].count()) {
        cout << "but also just " << crowd[maxA].count() - crowd[0].count() << " more than the current optimal path, " << crowd[0].count() << "!" << endl << endl;
    }
    else {
        cout << "but also just " << crowd[0].count() - crowd[maxA].count() << " less than the current optimal path, " << crowd[0].count() << "!" << endl << endl;
    }

    cout << ((float)max / crowd.size()) * 100 << "% of the crowd believed this would be the actual number of covered vertices required. " << endl;

    auto stop = high_resolution_clock::now();   // stop timer
    auto duration = duration_cast<microseconds>(stop - start);  // calculate elapsed time
    cout << "Program execution took " << duration.count() / 1000000.0 << "s" << endl << endl;

    system("pause");
    return 0;
}



//------------------------------------------------------------------------------
//  Function Definitions:
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//  Read .gph file, create edge objects and combine all in a graph object
//------------------------------------------------------------------------------
vector<Edge> buildGraph(char* argv) {
    // open .gph file in read-only mode:
    ifstream gphFile;
    gphFile.open(argv, ios::in);
    vector<Edge> graph;
    // ensure file exists:
    if (!gphFile.is_open()) {
        return graph;
    }
    string heading = "";
    // advance buffer to the edge section:
    while (heading.compare("200") != 0) {
        gphFile >> heading;
    }
    // create edge and push to graph vector
    Edge newEdge = Edge();
    for (int i = 0;i < E;i++) {
        gphFile >> heading;
        gphFile >> newEdge.u;
        gphFile >> newEdge.v;
        newEdge.covered = false;
        graph.push_back(newEdge);
    }
    // The graph is now created, and we are finished with the .TSP file
    gphFile.close();
    return graph;
}

//------------------------------------------------------------------------------
//  Return true if every edge in graph covered by at least one vertex.
//------------------------------------------------------------------------------
bool covered(vector<Edge> graph) {
    for (int i = 0; i < E; i++) {
        if (!graph[i].covered) {
            return false;
        }
    }
    return true;
}

//------------------------------------------------------------------------------
//  Creates minimum vertex cover from graph of shuffled edges and score 
//  detailing the connectivity of each vertex
//------------------------------------------------------------------------------
bitset<V> buildCover(vector<Edge> graph, array<int, V> score) {
    bitset<V> cover;
    int i = 0;
    int vertex = 0;
    while (!covered(graph)) {
        if (graph[i].covered) {
            i++;
            continue;
        }
        vertex = score[graph[i].u] > score[graph[i].v] ? graph[i].u : graph[i].v;
        cover[vertex] = true;
        for (int j = 0; j < E; j++) {
            if (graph[j].u == vertex || graph[j].v == vertex) {
                graph[j].covered = true;
            }
        }
        i++;
    }
    return cover;
}

//------------------------------------------------------------------------------
//  Simple flipped bit mutation method, flips bit of specified vertex and all 
//  those sharing edge
//------------------------------------------------------------------------------
bitset<V> mutate(bitset<V> o, vector<Edge> graph, int mutatee) {
    if (!o[mutatee]) {
        o[mutatee] = true;
    }
    else {
        o[mutatee] = false;
        for (int i = 0; i < E; i++) {
            if (graph[i].u == mutatee) {
                o[graph[i].v] = true;
            }
            else if (graph[i].v == mutatee) {
                o[graph[i].u] = true;
            }
            else {
                continue;
            }
        }
    }
    return o;
}

//------------------------------------------------------------------------------
//  Implementation of the Heuristic Vertex Crossover method by Drs. Kotecha and 
//  Gambhava of Department of Information Technology at G. H. Patel College of 
//  Engineering and Technology, Gujarat, India
//------------------------------------------------------------------------------
bitset<V> hvx(bitset<V> p1, bitset<V> p2, array<int, V> score, vector<Edge> graph, int mutatee) {
    bitset<V> o;

    // 1. Create VT(Table 1) and ET(Table 2)
    array<int, 101> VT;
    fill(VT.begin(), VT.end(), 0);
    for (int i = 1; i < V; i++) {
        if (p1[i]) {
            VT[i]++;
        }
        if (p2[i]) {
            VT[i]++;
        }
    }
    // score is N(x)
    // graph is ET

    //  until ET becomes empty and N(v) = 0 for all v in VT:
    while (!covered(graph)) {

        // 2. Select vertex with highest N(v) from VT.
        int  max = 0;
        for (int i = 0; i < VT.size(); i++) {
            if (VT[i] == 0) { continue; }
            if (score[i] > max) {
                max = i;
            }
        }
        score[max] = 0;

        // 3. Remove all the edges from ET, which are connected to vertex
        for (int j = 0; j < E; j++) {
            if (graph[j].u == max || graph[j].v == max) {
                graph[j].covered = true;
            }
        }

        // 4. Add vertex to the child cover
        o[max] = true;
    }

    // mutate if so doing:
    if (mutatee > 0) {
        o = mutate(o, graph, mutatee);
    }

    return o;
}

//------------------------------------------------------------------------------
//  Local optimisation technique checks if any vertices of given minimum vertex 
//  cover zeroable
//------------------------------------------------------------------------------
void lot(bitset<V>& o, vector<Edge> graph) {
    /*
    V’ = {1,5,3,2} but then also
    V’ = {1,3,2} covers all the edges.
    */
    int remove = 0;
    bool unnecessary = true;

    // For every vertex in o
    for (int i = 1; i < V; i++) {
        if (o[i]) {
            remove = i;
            unnecessary = true; // assume unnecessary unless shown otherwise

            // For every edge in graph check:
            for (int j = 0; j < E; j++) {

                // if there's the remove vertex,
                if (graph[j].u == remove) {

                    // then check the opposite vertex in o to see if graph[k].v is not true
                    if (!o[graph[j].v]) {   // if not true, then cannot zero safely
                        unnecessary = false;
                    }

                }
                else if (graph[j].v == remove) {
                    if (!o[graph[j].u]) {
                        unnecessary = false;
                    }
                }
                else { continue; }
            }

            if (unnecessary) {  // if covered still true, zero bit
                o[remove] = false;
            }

        }
    }
}

